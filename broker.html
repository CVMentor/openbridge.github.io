<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Openbridge.github.io by openbridge</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Openbridge Developer Documentation</h1>
        <p class="view">Visit us @ <a href="www.openbridge.com">www.openbridge.com</a> or if you need support site head over to <a href="openbridge.zendesk.com">openbridge.zendesk.com </a></p>
     
      </header>

      <section>
<h3 class="view"><a href="index.html">&lt;-Back to Home</a></h3>
<p><small>Last update: 12-02-2014</small></p><strong>Version: v1.0</strong>
       <h1>Openbridge Streaming Broker API</h1>
       <h2>Overview</h2>

       <p>The API is a powerful injest service for real-time (or close to real-time) data collection. The Openbridge API acts as a trusted broker between a client and a third party service enpoint. Those service endpoints can be RESTful, SOAP or employ any other HTTP based connection. </p>
       <p>The API employs standard HTTPS POST/GET to enable the broadest capatiblity to operate in diverse, yet standards based, development and production environments.</p>
       <p>The API can also be used to support webhooks offered by third parties for direct data collection from those systems. </p>
       <h2>Why Use A Broker?</h2>
<p>
The Broker allows you to store any transaction between two or more systems. Transactions include things like signups, profile updates, payments, redemptions or logins. All transaction events are automatically stored and routed to a dedicated cusotmer data store. 

<p>The Broker APIs are simple to implement and deploy and have the benefit of ensuring no impact to any legacy systems. This is especially important when downstream systems cannot be impacted in terms of their data models and access.

<p>
  Here are some of the uses cases the Openbridge Broker API supports;
<ul>
<li><strong>Immediate:</strong> By routing requests through the broker the you enable immediate, real-time access, to data that may otherwise be difficult to access or completely unavaialble due to restrictions in downstream systems.</li>
<li><strong>Simplicity:</strong> Allows any of your third party systems that support webhooks to stream data direclty to the API. You take your custom URL, paste it into the webhook field in your prefered tools, activate and any transactions occuring in your that tool will be streamed directly to you.</li>
<li><strong>Accuracy:</strong> You have clean or "pure" view of the transactional events. You can make decisions on how to process that data that meets your requirements. No more getting processed "exports" of transactional activity from downstream systems where data might have been manipulated or adjusted which alters the data in a manner that is undesirable, or worse, loses critical data signals you want to analize.</li>
<li><strong>Enrich</strong> The ability to append rich meta data to a transaction, even though client or service endpoint systems do not support the storage of those attributes. For example, appending campaign or tracking codes to transactions or attaching social media IDs to an enrollment activity on your site.</li>
<li><strong>Transparency:</strong> Provides full transparency of over all transactionactional activity between disparate systems for auditing and quality control. This includes the full details of requests from clients and responses from service enpoints.</li>
<li><strong>Mashup:</strong> Trigger external events based on the type of transaction. For example, based on a specific campaign or promo code present in a transaction the system triggers a a customer email on a remote system thanking them for their business, providing them a bounce-back offer to visit later in the week. <i>(Note: the mashup feature is in beta. Reach out to us if you are interested in being part of an early preview release)</i></li>
</ul>

<h2>How Does It Work?</h2>
<p>The basic process looks like this; </p>
<pre>

     +--------------+    +---------------+    +---------------+
     |              |    |               |    |               |
     |              |+-->|               |+-->|               |
     |              |    |               |    |               |
     |  client      |    |  broker       |    |  endpoint     |
     |              |<--+|               |<--+|               |
     |              |    |               |    |               |
     +--------------+    +---------------+    +---------------+
                                 +
                                 |
                         +------- -------+
                         |               |
                         |               |
                         |  storage      |
                         |               |
                         |               |
                         +---------------+

</pre>
<ul>
  <li><strong>Client:</strong> The broker supports any HTTP client, in any programming language, that can perform a HTTPS POST/GET. Client sends a request with host, header and body to service endpoint through the Broker API</li>
  <li><strong>Openbridge Broker API:</strong> Broker API processes the request header/body and delivers to the service endpoint host specified by the client. Broker mediates the response from the service enpoint back to the client</li>
  <li><strong>Storage:</strong> All requests from clients and responses from enpoints are captured and stored by the broker.  Openbridge will setup a dedicated broker for your account and supply a private URL to be used by clients for making POST/GET calls to service endpoints.</li>
  <li><strong>Service Enpoint:</strong>Service endpoint is a web service that accepts the mediated request from the Broker API based on the details supplied by the client application. Endpoint will respond with payload detailing the outcome of that request back to the Broker which passes it back to the client.</li>
</ul>
<h2>Requests</h2>
<h3> Service Enpoint Request Requirements</h3>
<p>While the Openbridge Broker API does not place special requirements on the request that is not true of the service endpoint you are likely calling. Make sure that your requests reflect the structure and format as detailed by the service endpoint you are calling. This includes all details relating to host, header and request body. If your request does not meet the specifications and requirements set forth by the service endpoint you will likely get HTTP or application level error codes in the response. If you are following the documentation service endpoint provides relating to constructing valid requests development and testing will move more quickly.</p>
<h3>Broker API Request Requirments and Options</h3>
<p>The Openbridge Broker API does not require any complex data mapping or schemas per se. The only requirements the Openbridge Broker API is that a request follows HTTP specifications, contains a valid credentials and follows the service enpoints request requirements. However, we do support more advanced use cases which allow you to append metadata to a request. </p>
<p>When you initiate a connection to Openbridge Broker API, there are some basic requirements that need to be met in order to successfully send data to a service endpoint and have us properly stora that data. </p>
<p>The documentation outlined below assumes your are embedding the API URL into your client application.</p>
<h3>Broker API Authentication</h3>
<p>The Broker API requires you pass a unique 32 bit key associated with URL as part of the payload. This means that the Broker API will require that the "api_key" is a required field as part of payload.
  
  For example, notice in the previous CURL request the presence of the "api_key";
  
<pre>curl --data '{"api_key":12344556, "host": "example.com", "port": 443, "is_ssl": true, "request": "POST / HTTP/1.0\r\nHost: example.com\r\nContent-Type: application/x-www-form-urlencoded\r\nContent-Length: 5\r\n\r\nfoooo"}' localhost/proxy</pre>
<p>If API Key is not associated with a request, then the server will Broker will resapond with 403 error. </p>
<p>For security purposes each key can is bound to the URL it was provisioned with. If you attempt to use an API key associated with another URL the server will reject the request. Also, if the API key has been expired or invalidated the server will not allow further requests for that specific URL. Please note, if the API Key was recently provisioned it may take between 5-10 minutes to have it propogate into our system. If you are still having an issue you can contact support for assistance.</p>
<h3>Broker API Base URL</h3>
<p>All Broker API URLs referenced in this documentation have the following base;</p>
<pre>https://api.openbridge.io</pre>

<p>The Openbridge Broker API is served over HTTPS. Unencrypted HTTP is allowed, but NOT recommeded. </p>

<h3>Broker API Sample POST & GET Requests</h3>
<p>To make a call, send a HTTPS POST request to your account's Broker URL. It will look something like this;</p>
<pre>https://api.openbridge.io/user/"product-id"/"account-sid"/"version"</pre>

<p>Sample CURL GET request:</p>
<pre>curl --data '{"api_key":12344556, "host": "example.com", "port": 443, "is_ssl": true, "label": "example", "request_id": 12345, "request": "GET / HTTP/1.0\r\nHost: example.com\r\n\r\n"}' localhost/proxy</pre>

<p>Sample CURL POST request:</p>
<pre>curl --data '{"api_key":12344556, "host": "example.com", "port": 443, "is_ssl": true, "label": "example", "request_id": 12345, "request": "POST / HTTP/1.0\r\nHost: example.com\r\nContent-Type: application/x-www-form-urlencoded\r\nContent-Length: 5\r\n\r\nfoooo"}' localhost/proxy</pre>

<ul>
  <li><strong>api_key:</strong> Authentication key. Think of it as a password</li>
  <li><strong>host:</strong> This is your target host name. For example if you need to send a request to Twitter API, then host parameter will be <tt>api.twitter.com</tt>. NOTE: this is not a host name of the Broker  </li>
  <li><strong>port:</strong> The port of the target system. Most likely it will be ether <tt>80</tt> for HTTP requests or <tt>443</tt> for HTTPS.  </li>
  <li><strong>is_ssl:</strong> It is a boolean that indicates where the connection from the Broker to the target system should be encypted. Please note that seting <tt>port</tt> argument to <tt>443</tt> will not implicitly wraps the connection with ssl. Most likely when the port is 80 this argument should be <tt>false</tt> and when the port is 443 this argument should be <tt>true</tt>. </li>
  <li><strong>label:</strong> Global identifier that helps you group the data together. Think of it as a table name in relational databases. For example imagine your request is to create a new account. Then give <tt>label</tt> a name that you would normaly give to the table name if you would store it in RDBMS. In that case it might be "account", "customer" or "subscription".  A label name must contain 1 to 64 alphanumeric characters. Also, it must contain only lowercase letters. <strong>IMPORTANT</strong>: <em>Labels are closely mapped to the payload resident in a request, including any metadata that was passed. The label is set in our system after the first request. This creates a coupling between the request and metadata to underlying data model. If the request and/or metadata changes, then you need to set a new label to reflect a new collection</em></li>
  <li><strong>request_id:</strong> Identifier that you set to request. This field might be something similar to the "Primary Key" or "Foreign Key" in RDBMS. It doesn't mean that any "Primary Key" functionality will be enforced. However it will definitely help you identifying records. For example: say you sending transaction data through the Broker. You may also track user activity on your website. If you set request_id to become a common field for both systems, then you will be able to easily link two reports together.  </li>
  <li><strong>request:</strong> HTTP request in <a href="http://tools.ietf.org/html/rfc2616">RFC 2616</a> format. This should be a full request with proper line brakes ('\r\n' instead of '\n') headers and everything else requiered by the RFC 2616. Please note that since the request is getting send as part of the JSON you must escape all of the characters that are not allowed by the JSON. We strongly recomend to not construct the full request to the Broker (<tt>{"host" ..., "port" ..., "request"}</tt>) by hand. Our suggestion is to construct a "dictionary" ( also known as "hash map", "associative array", "key value pairs" ) first and then use one of many existing tools to serialize obj to a JSON formatted string.
  </li></ul>
  
<p>For example:

Lets say you need to send a request to Twitter to update a back ground color on the user page.
Then your <tt>request</tt> field would look like similar to that:

<pre>"POST /1.1/account/update_profile_colors.json HTTP/1.1\r\nUser-Agent: curl/7.35.0\r\nHost: api.twitter.com\r\nAccept: /\r\nAuthorization: OAuth oauth_consumer_key=\"zZpVTtUIOSKZTmA\", oauth_nonce=\"cab82deasduvfo948c8a5\", oauth_signature=\"zv7apSPPPWAXUAF%2B%2Fm%2BeE%3D\", oauth_signature_method=\"HMAC-SHA1\", oauth_timestamp=\"1415380171\", oauth_token=\"160ABCD12O\", oauth_version=\"1.0\"\r\nContent-Length: 126\r\nContent-Type: application/x-www-form-urlencoded\r\nConnection: close\r\n\r\nprofile_text_color=000000&profile_sidebar_border_color=ff0000&skip_status=1&profile_background_color=0000FF&include_entities=1"
</pre>

<p>Lets got step by step:</p>
<ul>
  <li><tt>POST /1.1/account/update_profile_colors.json HTTP/1.1</tt> is a required HTTP signature. This will be different depending on the type of your request, the end point and the HTTP version.</li>
  <li><tt>\r\n</tt> Required instead of single '\n'</li>
  <li><tt>User-Agent ... Connection: close</tt> Is a required header. Please note that this header is required by the target system, not by the Broker. NOTE if "Connection: close" is not set, you need to set it explisitly. </li>
  <li><tt>\r\n\r\n</tt> Is a required delimiter (2 blank lines) between the header and the body of the POST request.</li>
  <li><tt>profile_text ... entities=1</tt></li>
</ul>


<p>Another usecase may be sending a SOAP request to a target system. It's not much different than sending a post request to Twitter. The same rules applied: set the proper header (SOAPAction in this case), two line brakes between the soap envelop and the header. You can then fully construct the XML:</p>

<pre>"POST /xml HTTP/1.1\r\nHost: example.com ... Content-Type: text/xml; charset=ISO-8859-1 SOAPAction: ...  Expect: 100-continue ... Connection: close \r\n\r\n<?xml version='1.0' encoding='ISO-8859-1'?>\n<SOAP-ENV:Envelope xmlns:SOAP-ENV=\"http://schemas.xmlsoap.org/soap/envelope/\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\ ... <SOAP-ENV:Header> ...  </SOAP-ENV:Header>\n  <SOAP-ENV:Body>\n ...  </SOAP-ENV:Body>"
</pre>


<h2>Enriching Your Request With  Metadata</h2>
<p>We allow you to append additional metadata to a request that may not otherwise be possible due to limitations on the client or service endpoint sides. For example, a service endpoint may be very rigid in what in the payloads you to deliver. When including metadata in a request Openbridge will store those details, however we will not pass an of that metadata to the service endpoint. This enables you to piggyback additional details on each transaction while not impacting the service endpoint. For exmaple;</p>
<ul>
  <li><strong>Marketing Activity:</strong> Capturing infromation about the details of a campaign, such as the source/channel/creative, that might be driving spepcific activity like an enrollment.</li>
  <li><strong>Profile Enrichment:</strong> Additional data such as demographics, location, a favorite movie, prefered contact method or third party IDs/keys</li>
  <li><strong>Security and Auditing:</strong> Additional metadata may represent data that you want to make sure is recorded for a transaction, yet not exposed to a downstream service endpoint. This maybe useful in situations where you need to reconcile activity due to financial considerations like chargebacks per successful transctions, but not for failed or rejected ones.</li>
</ul>
<h3>How To Included Metadata Properties In Your Request</h3>
<p> Metadata properties are highly flexible and customizable.  However, you should be cognizent of some basic rules to help ensure that the data is usable.</p>
<p>Shell:</p>
<pre>
&quot;host&quot;: &quot;hostname.serviceendpoint.com&quot;,
&quot;meta&quot;: {
&quot;name1&quot;: &quot;value&quot;,
&quot;name2&quot;: &quot;123&quot;,
&quot;name3&quot;: &quot;my string with quotes and new line characters \&quot; \n\n \r\\s\t\\y&quot;
}, <br>
&quot;request_id&quot;: &quot;local&quot;,
&quot;is_ssl&quot;: true,
&quot;api_key&quot;: &quot;12qwe@&quot;,
&quot;request&quot;: &quot;POST members.......&quot;,
&quot;port&quot;: 443,
&quot;label&quot;: &quot;test&quot;
}
</pre>

<p>Example:</p>
<pre>
&quot;host&quot;: &quot;hostname.serviceendpoint.com&quot;,
&quot;meta&quot;: {
&quot;accountID&quot;: &quot;1QASADSDA&quot;,
&quot;socialID&quot;: &quot;twitter-fredsmith&quot;,
&quot;loyaltyID&quot;: &quot;A1234-12344&quot;,
&quot;promoCode&quot;: &quot;QSWW2014&quot;,
&quot;sourceCampaignID&quot;: &quot;123SGGGDFA12348&quot;,
}, <br>
&quot;request_id&quot;: &quot;local&quot;,
&quot;is_ssl&quot;: true,
&quot;api_key&quot;: &quot;12qwe@&quot;,
&quot;request&quot;: &quot;POST members.......&quot;,
&quot;port&quot;: 443,
&quot;label&quot;: &quot;userenrollment&quot;
}
</pre>

<p>The "request" contains all the pertinent user enrollment information such as name, address, phone number and email address. However, the underlying application and data systems cannot be modified to accomodate additional data points. Using metadata allows you to set additional entities as an overlay to base request payload, ensuring enable greater context can be overlayed into the transaction.

<h3>Requirements For Metadata Properties In Your Request</h3>
<p>The following are the properties for request metadata;</p>
<p><strong>Names & Values</strong></p>
<ul>
  <li>Must be less than 256 characters long</li>
  <li>Contain only ASCII letters, digits, underscore characters (_), or dollar signs ($)</li>
  <li>Contain no quotation marks and no spaces</li>
    <li>Begin with an alphabetic character or underscore character. Subsequent characters may include letters, digits, underscores, or dollar signs</li>
  
  <li>Cannot be null</li>
  <li>Can use JSON syntax as a data format. However, do not use nested hierarchy for your properties</li>
  <li>A date or timestamp literal must be enclosed in quotes</li>
</ul>
<p>If you take care to put structure your metadata this way, any data anlaysis or triggering remote events based on the supplied data becomes easierto process. We advise putting some thought into this part of the process as it will help you avoid the old adage of "garbage in, garbage out", something the analysts or developer will thank you for.</p>

<h2>Response Codes</h2>
<h3>Service Enpoint Response Codes</h3>
<p>The Openbridge Broker API will echo back to your client the response codes presented to us by the service endpoint. Those may be a combination of HTTP response codes as well as application specific codes resident in a response payload. Your application should take care to handle both situations. For example, is the Openbridge Broker API responds to your request with "Request Not Allowed: 403 Forbidden". This means the service enpoint has rejected the request, possibly due to an issue in how you are supplying your credentials. Please pay careful attention to the documentation provided by the service endpoint to to assist your application development, testing and deployment efforts.
</p>
<h3>Broker API Response Codes</h3>
<p>As mentioned previouslly the Openbridge Broker API will responds to your request with "Request Not Allowed: 403 Forbidden" in the event of an error with your API key. Also, if your request is malformed in anyway then we will also respond with standard HTTP response code prior to sending it to a service enpoint. The following are examples of the of the Openbridge Broker API response codes.</p>
<ul>
  <li><strong>202 Accepted</strong>: The request has been accepted for processing, but the processing has not been completed. The request might or might not eventually be acted upon, as it might be disallowed when processing actually takes place. There is no facility for re-sending a status code from an asynchronous operation such as this.</li>
   <li><strong>403 Forbidden</strong>: The server understood the request, but is refusing to fulfill it. Authorization will not help and the request SHOULD NOT be repeated. If the request method was not HEAD and the server wishes to make public why the request has not been fulfilled, it SHOULD describe the reason for the refusal in the entity. </li>
  <li><strong>503 Service Unavailable:</strong> The server is currently unable to handle the request due to a temporary overloading or maintenance of the server. The implication is that this is a temporary condition which will be alleviated after some delay. If known, the length of the delay MAY be indicated in a Retry-After header. If no Retry-After is given, the client SHOULD handle the response as it would for a 500 response</li>
</ul>
<h2>Broker API Event Processing</h2>
<h3>Data Pipelining &amp; Storage</h3>
<p>Since the request body is often slow changing in terms of what is sent as a payload, adjsuting the request body may not happen frequently. However, in the event there are changes in a request body, such as a new attribute, it signals you have changed the underlying data structures. When we detect these changes we simply version the data in your vault. Think of a version as starting a new snapshot. These different snapshots allow you audit changes over time.</p>
      </section>
      <footer>
        <p><small>Hosted on GitHub Pages</small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>

  </body>
</html>
